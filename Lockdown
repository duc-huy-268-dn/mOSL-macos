#!/usr/bin/env bash
# mOSL/Lockdown

# Lockdown
declare -r LOCKDOWN_VERSION="v1.0"

set -uo pipefail
# -u prevent using undefined variables
# -o pipefail force pipelines to fail on first non-zero status code

IFS=$'\n\t'
# Set Internal Field Separator to newlines and tabs
# This makes bash consider newlines and tabs as separating words
# See: http://redsymbol.net/articles/unofficial-bash-strict-mode/

### Define Colours ###

/usr/bin/tput sgr0;
# reset colors

readonly RED="$(/usr/bin/tput setaf 1)"
readonly RESET="$(/usr/bin/tput sgr0)"
readonly BOLD="$(/usr/bin/tput bold)"

### END Colours ###


function usage {
  echo -e "\\n  Audit or Fix macOS security settingsüîíüçé\\n"
  echo -e "  Usage: ./Lockdown [list | audit {setting} | fix {setting} | version | debug]\\n"

  echo "    list         - List settings that can be audited/ fixed"
  echo "    audit        - Audit the status of all or chosen setting"
  echo "    fullaudit    - Audit the status of all or chosen setting and dump basic information hardware and name Application"
  echo -e "    ${RED}fix${RESET}          - Attempt to fix all or chosen setting\\n"
  echo "    ${RED}fix-force${RESET}    - Same as 'fix' however bypasses user confirmation prompt"
  echo -e "                   (Can be used to invoke Lockdown from other scripts)\\n"
  echo "    version      - Print Lockdown version string"
  echo -e "    debug        - Print debug info for troubleshooting\\n"
  exit 0
}


### UTILITY FUNCTIONS ###
# macos_compatability_check
# audit
# fix
# mode_check
# get_fix_mode_permission
# follow_symlink
# verify_signature
# check_index
# sudo_prompt
# ctrl_c
# check_if_vm
# check_sip
# debug
# full_disk_access_check
# version


function macos_compatability_check {

  # Check if running on a Mac
  # Check if the Mac is running the supoorted version of macOS

  local -r supported_macos_versions="10.13 10.14 10.15"
  #local -r supported_macos_versions="11.0 11.1 11.2 11.3"
  local os
  local current_macos_version

  os="$(/usr/bin/uname -s)"

  if [[ "${os}" != "Darwin" ]]; then
    echo "[‚ùå] Lockdown was built for macOS"
    exit 1
  fi

  current_macos_version="$(/usr/bin/sw_vers -productVersion | /usr/bin/awk -F '.' '{print $1 "." $2}')";

  echo $supported_macos_versions | grep -w -q $current_macos_version
  if [[ $? -ne 0 ]]; then
    #echo "[‚ùå] Lockdown was built for macOS ${supported_macos_version}.x"
    #echo "[üç∫] This is macOS ${current_macos_version}"
    #exit 1 - Original
    return 1
  fi
}


function audit {

  local title=${1:?No title passed}
  local command=${2:?No command passed}

  if bash -c "${command}"; then
    if [[ "${cmd}" = "fullaudit" ]]; then
      echo "     <AuditPass> Pass-${title} </AuditPass>" >> $xml_file
    fi
    echo "  [‚úÖ] ${title}"
    return 0
  else
    if [[ "${cmd}" = "fullaudit" ]]; then
      echo "     <AuditFail> Fail-${title} </AuditFail>" >> $xml_file
    fi
    echo "  [‚ùå] ${title}"
    return 1
  fi
}

function fix {

  local title=${1:?No title passed}
  local command=${2:?No command passed}

  if [[ "${command}" == "null" ]]; then
    echo "  [‚ö†Ô∏è ] ${BOLD}Can't fix${RESET}: ${title}"
    return 1
  fi

  if bash -c "${command}"; then
    echo "  [‚úÖ] ${BOLD}FIXED${RESET}: ${title}"

    if [[ "${title}" == "Check SIP enabled" ]]; then
      echo "  [‚ö†Ô∏è ] ${BOLD}Reboot required for SIP configuration changes to take effect"
    fi
    return 0
  else
    echo "  [‚ùå] ${BOLD}Failed to fix${RESET}: ${title}"
    return 1
  fi
}


function mode_check {

  local mode=${1:?}
  local title=${2:?}
  local audit_command=${3:?}
  local fix_command=${4:-"null"}

  if [[ "${mode}" == "audit" ]]; then
    audit "${title}" "${audit_command}"

  elif [[ "${mode}" == "fix" ]]; then
    fix "${title}" "${fix_command}"
  fi
}


function get_fix_mode_permission {

  # Double check with user before making changes to their system

  local fix_mode_permission=""

  echo "[‚ö†Ô∏è ] You are about to engage ${BOLD}${RED}FIX${RESET} mode which ${BOLD}${RED}WILL${RESET} make changes to your Mac üíª"
  echo -n "[‚ö†Ô∏è ] Do you want to continue? (y/${BOLD}N${RESET}) "
  read -r fix_mode_permission

  if [[ "${fix_mode_permission}" =~ ^(y|Y)$ ]]; then

    echo "[‚úÖ] ${USER} has chosen to continue"
    sudo_prompt
    return 0

  else
    echo "[‚ùå] ${USER} has chosen to quit!"
    exit 1
  fi
}

function check_index {

  # Check that index supplied to audit/ fix isn't greater than the number of entries in settings

  local setting_num=${1:-0}
  local -i max_setting_num
  max_setting_num=$(( ${#settings[@]} - 1 ))

  if ! [[ "${setting_num}" =~ ^-?[0-9]+$ ]] ; then
   echo -e "\\n  [‚ùå] ${setting_num} ${RED}is not an integer!${RESET}"
   echo "  [‚ö†Ô∏è ] Pick a setting between 1 and ${max_setting_num}"
   exit 1
  fi

  if [ "${setting_num}" -gt "${max_setting_num}" ]; then
    echo -e "\\n  [‚ùå] ${RED}No setting with index of ${setting_num}${RESET}"
    echo "  [‚ö†Ô∏è ] Pick a setting between 1 and ${max_setting_num}"
    exit 1
  fi
}


function sudo_prompt {

  sudo --prompt="[‚ö†Ô∏è ] Password required to run some commands with 'sudo': " -v
  # Aquire sudo privlidges now so we can show a custom prompt
  # -v updates the user's cached credentials, does not run a command
}


function ctrl_c {

        echo -e "\\n[‚ùå] ${USER} has chosen to quit!"
        exit 1
}

function check_if_vm {

  if system_profiler SPHardwareDataType | grep -q "VMware";  then
    # TODO: Only detects VMware. Add VirtualBox, Parallels, generic?
    return 0
  else
    return 1
  fi
}

function check_sip {

  if csrutil status | grep -q "enabled"; then
    return 0
  else
    return 1
  fi
}

function debug {

  local is_admin="False"
  local has_full_disk_access="False"

  if /usr/bin/groups | /usr/bin/grep -q 'admin'; then
    is_admin="True"
  fi

  if full_disk_access_check; then
    has_full_disk_access="True"
  fi

  if check_if_vm; then
    is_vm="True"
  fi

  if verify_signature >/dev/null 2>&1; then
    is_codesigned="True"
    # If the signature has been broken and you uncomment the
    # call to verify_signature in main and try to run
    # ./Lockdown debug this verify_signature call will still
    # exit 1 with no explanation
  fi

  if check_sip; then
    sip="True"
  fi

  echo -e "${RED}Debug information:${RESET} \\n"

  echo "      mOSL Version:   ${LOCKDOWN_VERSION}"
  /usr/sbin/system_profiler SPSoftwareDataType | /usr/bin/grep 'Version'
  echo "      Is admin:       ${is_admin}"
  echo "      Full Disk Access: ${has_full_disk_access}"
  echo "      Virtual Machine: ${is_vm}"
  echo "      Codesigned:      ${is_codesigned}"
  # Codesigned will only ever be "True" or "no minisign" as
  # verify_signature is the first thing called in main so Lockdown
  # will exit before it evaluates $cmd
  echo "      SIP:             ${sip}"
  echo "      T2:              ${t2_mac}"
  echo

  exit 0
}


function full_disk_access_check {

  if [ -r "$HOME/Library/Mail" ]; then
    return 0
  else
    return 1
  fi
}

function version {
  echo "${LOCKDOWN_VERSION}"
}


### END UTILITY FUNCTIONS ###


function disable_automatic_system_updates {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command
  title="0 - Disable Automatic Install System Updates"

  # shellcheck disable=SC2016
    audit_command='if ! defaults read "/Library/Preferences/com.apple.SoftwareUpdate.plist" "AutomaticallyInstallMacOSUpdates" >/dev/null 2>&1; then exit 1; fi; defaults read "/Library/Preferences/com.apple.SoftwareUpdate.plist" AutomaticallyInstallMacOSUpdates | grep -q "0"'
    fix_command='declare -a keys; keys=(AutomaticDownload AutomaticallyInstallMacOSUpdates); for key in "${keys[@]}"; do sudo defaults write "/Library/Preferences/com.apple.SoftwareUpdate.plist" "${key}" -bool false; done'

    mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function disable_automatic_app_store_updates {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command

  title="1 - Disable Automatic App Store Updates"

  audit_command='if ! defaults read "/Library/Preferences/com.apple.commerce.plist" "AutoUpdate" >/dev/null 2>&1; then exit 1; fi; defaults read "/Library/Preferences/com.apple.commerce.plist" AutoUpdate | grep -q "0"'
  fix_command="sudo defaults write '/Library/Preferences/com.apple.commerce.plist' 'AutoUpdate' -bool false"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}

function set_5minute_time_lock_and_sleep_computer {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command

  title="4 - 5 Minutes to lock and sleep computer"
  audit_command="sudo systemsetup -getdisplaysleep | grep -q '5 minutes'"
  fix_command="sudo systemsetup -setcomputersleep 5 > /dev/null ;sudo systemsetup -setdisplaysleep 5 > /dev/null ;$(osascript -e 'tell application "System Events" to set require password to wake of security preferences to true')"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}

function disable_firewall {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command

  title="2 - Disable Firewall"

  audit_command="sudo /usr/libexec/ApplicationFirewall/socketfilterfw  --getglobalstate | grep -q 'disabled'"
  fix_command="sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setglobalstate off >/dev/null"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function enable_admin_password_preferences {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command

  title="3 - Require an administrator password to access system-wide preferences"

  audit_command="security -q authorizationdb read system.preferences | grep -A1 'shared' | grep -q 'false'"
  fix_command="security -q authorizationdb read system.preferences > /tmp/system.preferences.plist; /usr/libexec/PlistBuddy -c 'Set :shared false' /tmp/system.preferences.plist; sudo security -q authorizationdb write system.preferences < /tmp/system.preferences.plist; rm '/tmp/system.preferences.plist'"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function enable_terminal_secure_entry {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command

  title="5 - Enable Terminal.app secure keyboard entry"

  audit_command="defaults read com.apple.Terminal SecureKeyboardEntry | grep -q '1'"
  fix_command="defaults write com.apple.Terminal SecureKeyboardEntry -bool true"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}

function enable_filevault {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command
  local permission="n"

  title="6 - Enable FileVault"

  audit_command="fdesetup status | grep -q 'On'"
  fix_command="sudo fdesetup enable -user $USER > $HOME/FileVault_recovery_key.txt"


  if [[ "${mode}" == "fix" ]]; then

    if ! /usr/sbin/diskutil info / | /usr/bin/grep 'File System Personality:' | /usr/bin/grep -q 'APFS'; then
      # Only offer to enable if the filesystem is APFS
      return 1
    elif [[ "${cmd}" == "fix-force" ]]; then
      # Exit if Lockdown invoked with fix-force
      # Enabling FDE should be explicit, don't want anyone to do this by accident
      echo "  [‚ö†Ô∏è ] ${BOLD}Didn't fix${RESET}: ${title}"
      return 1
    fi

    echo -en "\\n  [‚ö†Ô∏è ] Do you want to ${RED}enable FileVault${RESET}? (y/${BOLD}N${RESET}) "
    read -r permission

    if [[ "${permission}" =~ ^(y|Y)$ ]]; then

      echo "  [‚úÖ] ${USER} has chosen to enable FileVault"
      echo -e "  [‚ö†Ô∏è ] Recovery key saved to ${RED}$HOME/FileVault_recovery_key.txt${RESET}\\n"

    else
      echo -e "  [‚ùå] ${USER} has chosen ${BOLD}not${RESET} to enable FileVault\\n"
      return 1
    fi
  fi

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}


function disable_remote_login {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command

  title="7 - Disable Remote Login"

  audit_command="sudo systemsetup -getremotelogin | grep -q 'Remote Login: Off'"
  fix_command="sudo systemsetup -f -setremotelogin off >/dev/null"

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
}

function delete_firmware_password {

  local mode=${1:?No mode passed}
  local title
  local audit_command
  local fix_command
  local permission="n"
  processor_description=$(sysctl -n machdep.cpu.brand_string | grep -q "Apple")
  ###
  if [[ $? -ne 0 ]]; then
  title="8 - Delete a firmware password"
  audit_command="sudo firmwarepasswd -check | grep -q 'Ye‚ÄØ'"
  fix_command="sudo firmwarepasswd -delete"

    if [[ "${mode}" == "fix" ]]; then

      if [[ "${cmd}" == "fix-force" ]]; then
        # Exit if Lockdown invoked with fix-force
        # Enabling FDE should be explicit, don't want anyone to do this by accident
        echo "  [‚ö†Ô∏è ] ${BOLD}Didn't fix${RESET}: ${title}"
        return 1
      fi

      echo -en "\\n  [‚ö†Ô∏è ] Do you want to ${RED}remove a Firmware password?${RESET} (y/${BOLD}N${RESET}) "
      read -r permission

      if [[ "${permission}" =~ ^(y|Y)$ ]]; then
        echo "  [‚úÖ] ${USER} has chosen to remove a firmware password"
      else
        echo -e "  [‚ùå] ${USER} has chosen ${BOLD}not${RESET} to remove a firmware password\\n"
        return 1
      fi
    fi

  mode_check "${mode}" "${title}" "${audit_command}" "${fix_command}"
  else
    echo "  [üç∫] # - SKIP Delete a firmware password for Apple Chip (Unsupported)"
  fi
  ###
}

function getinfo {
#  Copyright 2003-2015 Opmantek Limited (www.opmantek.com)
#
#  ALL CODE MODIFICATIONS MUST BE SENT TO CODE@OPMANTEK.COM
#
#  This file is part of Open-AudIT.
#
#  Open-AudIT is free software: you can redistribute it and/or modify
#  it under the terms of the GNU Affero General Public License as published
#  by the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  Open-AudIT is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU Affero General Public License for more details.
#
#  You should have received a copy of the GNU Affero General Public License
#  along with Open-AudIT (most likely in a file named LICENSE).
#  If not, see <http://www.gnu.org/licenses/>
#
#  For further information on Open-AudIT or for a license other than AGPL please see
#  www.opmantek.com or email contact@opmantek.com
#
# *****************************************************************************

# @package Open-AudIT
# @author Mark Unwin <marku@opmantek.com>
#
# @version   GIT: Open-AudIT_3.5.2

# @copyright Copyright (c) 2014, Opmantek
# @license http://www.gnu.org/licenses/agpl-3.0.html aGPL v3

O=$IFS
IFS=$'\n'

export PATH=$PATH:/usr/sbin
#local system_hostname
local system_timestamp
local hard_drive_serial
local hard_drive_firmware
#local partition_serial
local software_publisher
local final_file
url="http://localhost/open-audit/index.php/input/devices"
submit_online="n"
create_file="y"
discovery_id=""
org_id=""
terminal_print="n"
debugging="3"
system_id=""
last_seen_by="audit"

# Version
version="3.5.2"

# DO NOT REMOVE THE LINE BELOW
# Configuration from web UI here

# import the command line arguements
for arg in "$@"; do
    parameter=${arg%%=*}
    value=${arg##*=}
    if [ "$parameter" == "--help" ]; then parameter="help"; value="y"; fi
    if [ "$parameter" == "-h" ]; then parameter="help"; value="y"; fi
    eval "$parameter"=\""$value\""
done

#if [ "$help" = "y" ]; then
#    echo ""
#    echo "---------------------------"
#    echo "Open-AudIT OSX audit script"
#    echo "Version: $version"
#    echo "---------------------------"
#    echo "This script should be run on a Mac OSX based computer using root or sudo access rights."
#    echo ""
#    echo "Valid command line options are below (items containing * are the defaults) and should take the format name=value (eg: debugging=1)."
#    echo ""
#    echo "  create_file"
#    echo "     y - Create an XML file containing the audit result."
#    echo "    *n - Do not create an XML result file."
#    echo ""
#    echo "  debugging"
#    echo "     0 - No output."
#    echo "     1 - Minimal Output."
#    echo "     2 - Verbose output."
#    echo "    *3 - Very Verbose output."
#    echo ""
#    echo "  discovery_id"
#    echo "     * - The Open-AudIT discovery id. This is populated by Open-AudIT when running this script from discovery."
#    echo ""
#    echo "  -h or --help or help=y"
#    echo "      y - Display this help output."
#    echo "     *n - Do not display this output."
#    echo ""
#    echo "  org_id"
#    echo "       - The org_id (an integer) taken from Open-AudIT. If set all devices found will be associated to that Organisation."
#    echo ""
#    echo "  submit_online"
#    echo "    *y - Submit the audit result to the Open-AudIT Server defined by the 'url' variable."
#    echo "     n - Do not submit the audit result"
#    echo ""
#    echo "  url"
#    echo "    *http://localhost/open-audit/index.php/discovery/process_subnet - The http url of the Open-AudIT Server used to submit the result to."
#    echo ""
#    echo ""
#    echo "The name of the resulting XML file will be in the format HOSTNAME-YYMMDDHHIISS.xml, as in the hostname of the machine the the complete timestamp the audit was started."
#    exit
#fi

#system_hostname=$(hostname | cut -d. -f1)
#xml_file="$system_hostname"-`date +%Y%m%d%H%M%S`.xml
#xml_file_full_path=`pwd`"/$xml_file"

if [  "$debugging" -gt 0 ]; then
    echo "----------------------------"
    echo "Open-AudIT OSX audit script"
#    echo "Version: $version"
    echo "----------------------------"
    echo "My PID is           $$"
    echo "Audit Start Time    $system_timestamp"
    echo "Create File         $create_file"
#    echo "Submit Online       $submit_online"
    echo "Debugging Level     $debugging"
#    echo "Discovery ID        $discovery_id"
#    echo "Org Id              $org_id"
    echo "File                $xml_file_full_path"
    echo "----------------------------"
fi

if [ "$debugging" -gt "2" ]; then
    echo "System Info"
fi
system_timestamp=$(date +'%F %T')
system_uuid=$(system_profiler SPHardwareDataType | grep "Hardware UUID:" | cut -d":" -f2 | sed 's/^ *//g')

if [[ $system_hostname == *"."* ]]; then
    system_domain=$(hostname | cut -d. -f2-)
else
    system_domain=""
fi
system_os_version=$(sw_vers | grep "ProductVersion:" | cut -f2)
system_os_version_major=$(echo "$system_os_version" | cut -d. -f1)
system_os_version_minor=$(echo "$system_os_version" | cut -d. -f2)
system_os_name="OSX $system_os_version"
system_serial=$(system_profiler SPHardwareDataType | grep 'Serial Number (system):' | cut -d':' -f2 | sed 's/^ *//g')
manufacturer_code=""
if [[ ${#system_serial} = 11 ]]; then
    manufacturer_code=${system_serial: -3}
fi
if [[ ${#system_serial} = 12 ]]; then
    manufacturer_code=${system_serial: -4}
fi
system_model=$(system_profiler SPHardwareDataType | grep 'Model Identifier:' | cut -d':' -f2 | sed 's/^ *//g')
# todo - below displays days and stops at hours
# system_uptime=`system_profiler SPSoftwareDataType | grep "Time since boot:" | cut -d":" -f2 | sed 's/^ *//g'`
system_uptime=""
system_form_factor=""
system_pc_os_bit="64"
system_pc_memory=$(system_profiler SPHardwareDataType | grep 'Memory:' | cut -d':' -f2 | sed 's/^ *//g' | cut -d' ' -f1)
system_pc_memory=$(expr "$system_pc_memory" \* 1024 \* 1024)
processor_count=$(system_profiler SPHardwareDataType | grep 'Number of Processors' | cut -d: -f2)
system_pc_date_os_installation=$(date -r $(stat -f "%B" /private/var/db/.AppleSetupDone) "+%Y-%m-%d %H:%M:%S")

echo  " <sys>" >> $xml_file
echo "      <script_version>$version</script_version>" >> $xml_file
echo  "     <timestamp>$system_timestamp</timestamp>" >> $xml_file
echo  "     <id>$system_id</id>" >> $xml_file
echo  "     <uuid>$system_uuid</uuid>" >> $xml_file
echo  "     <hostname>$system_hostname</hostname>" >> $xml_file
echo  "     <domain>$system_domain</domain>" >> $xml_file
echo  "     <description></description>" >> $xml_file
echo  "     <class></class>" >> $xml_file
echo  "     <type>computer</type>" >> $xml_file
echo  "     <os_group>Apple</os_group>" >> $xml_file
echo  "     <os_family>Apple OSX</os_family>" >> $xml_file
echo  "     <os_name>$system_os_name</os_name>" >> $xml_file
echo  "     <os_version>$system_os_version</os_version>" >> $xml_file
echo  "     <serial>$system_serial</serial>" >> $xml_file
echo  "     <model>$system_model</model>" >> $xml_file
echo  "     <manufacturer>Apple, Inc.</manufacturer>" >> $xml_file
echo  "     <manufacturer_code>$manufacturer_code</manufacturer_code>" >> $xml_file
echo  "     <uptime>$system_uptime</uptime>" >> $xml_file
echo  "     <form_factor></form_factor>" >> $xml_file
echo  "     <os_bit>$system_pc_os_bit</os_bit>" >> $xml_file
echo  "     <memory_count>$system_pc_memory</memory_count>" >> $xml_file
echo  "     <processor_count>$processor_count</processor_count>" >> $xml_file
echo  "     <os_installation_date>$system_pc_date_os_installation</os_installation_date>" >> $xml_file
echo  "     <org_id>$org_id</org_id>" >> $xml_file
echo  "     <last_seen_by>$last_seen_by</last_seen_by>" >> $xml_file
echo  "     <discovery_id>$discovery_id</discovery_id>" >> $xml_file
echo  " </sys>" >> $xml_file

if [ "$debugging" -gt "2" ]; then
    echo "BatteryData Info"
fi

bat_design=$(ioreg -r -n AppleSmartBattery | grep '"DesignCapacity" =' | awk '{print $3}')
bat_cycle=$(system_profiler SPPowerDataType | grep "Cycle Count" | awk '{print $3}')
bat_condition=$(system_profiler SPPowerDataType | grep "Condition" | awk '{print $2}')
bat_current_capacity=$(ioreg -r -n AppleSmartBattery | grep '"AppleRawMaxCapacity" =' | awk '{print $3}')
bat_wear_level=$(echo "scale=2;(1-$bat_current_capacity/$bat_design)*100" | bc -l | sed '/\./ s/\.\{0,1\}0\{1,\}$//')

echo  " <battery>" >> $xml_file
echo  "     <item>" >> $xml_file
echo  "         <design_capacity>$bat_design</design_capacity>" >> $xml_file
echo  "         <current_capacity>$bat_current_capacity</current_capacity>" >> $xml_file
echo  "         <wear_level>$bat_wear_level</wear_level>" >> $xml_file
echo  "         <cycle>$bat_cycle</cycle>" >> $xml_file
echo  "         <condition>$bat_condition</condition>" >> $xml_file
echo  "     </item>" >> $xml_file
echo  " </battery>" >> $xml_file

if [ "$debugging" -gt "2" ]; then
    echo "Network Cards Info"
fi
ip_info=""
echo "  <network>" >> $xml_file
for line in $(system_profiler SPNetworkDataType | grep "BSD Device Name: en" | cut -d":" -f2); do
    line=`echo "${line}" | awk '{gsub(/^ +| +$/,"")} {print $0}'`
    net_mac_address=`ifconfig $line 2>/dev/null | grep "ether" | awk '{print $2}'`
    i=`system_profiler SPNetworkDataType | grep "BSD Device Name: $line" -B 4 | grep ":" | grep -v "      " | cut -d":" -f1`
    i=`echo "${i}" | awk '{gsub(/^ +| +$/,"")} {print $0}'`
    j=`system_profiler SPNetworkDataType | grep "BSD Device Name: $line" -B 3 | grep ":" | grep "Type" | cut -d":" -f2`
    j=`echo "${j}" | awk '{gsub(/^ +| +$/,"")} {print $0}'`
    net_index="$line"
    net_manufacturer="Apple"
    net_model="$i"
    net_description="$i $j"
    net_ip_enabled=`system_profiler SPNetworkDataType | grep "BSD Device Name: $line" -A 1 | grep ":" | grep "Has IP Assigned" | cut -d":" -f2 | cut -d" " -f2`
    net_connection_id="$line"
    net_speed=""
    net_adapter_type="$j"
    if [[ "$net_mac_address" > "" ]]; then
        echo "      <item>" >> $xml_file
        echo "          <net_index>$net_index</net_index>" >> $xml_file
        echo "          <mac>$net_mac_address</mac>" >> $xml_file
        echo "          <manufacturer>$net_manufacturer</manufacturer>" >> $xml_file
        echo "          <model>$net_model</model>" >> $xml_file
        echo "          <description>$net_description</description>" >> $xml_file
        echo "          <ip_enabled>$net_ip_enabled</ip_enabled>" >> $xml_file
        echo "          <connection>$net_connection_id</connection>" >> $xml_file
        echo "          <type>$net_adapter_type</type>" >> $xml_file
        echo "      </item>" >> $xml_file
    fi
done
echo "  </network>" >> $xml_file
echo "  <ip>" >> $xml_file
for line in $(system_profiler SPNetworkDataType | grep "BSD Device Name: en" | cut -d":" -f2); do
    line=`echo "${line}" | awk '{gsub(/^ +| +$/,"")} {print $0}'`
    net_mac_address=`ifconfig $line 2>/dev/null | grep "ether" | awk '{print $2}'`
    if [[ "$net_mac_address" > "" ]]; then
        ip_address_v4=`ipconfig getifaddr $line`
        if [[ "$ip_address_v4" > "" ]]; then
            net_index="$line"
            ip_subnet=`ipconfig getpacket $line | grep "subnet_mask" | cut -d" " -f3`
            echo "      <item>" >> $xml_file
            echo "          <net_index>$net_index</net_index>" >> $xml_file
            echo "          <mac>$net_mac_address</mac>" >> $xml_file
            echo "          <ip>$ip_address_v4</ip>" >> $xml_file
            echo "          <netmask>$ip_subnet</netmask>" >> $xml_file
            echo "          <version>4</version>" >> $xml_file
            echo "      </item>" >> $xml_file
        fi
    fi
done
echo "  </ip>" >> $xml_file


if [ "$debugging" -gt "2" ]; then
    echo "Processor Info"
fi

processor_cores=`system_profiler SPHardwareDataType | grep "Total Number of Cores" | awk '{print $5}'`
processor_logical=`sysctl hw.ncpu | awk '{print $2}'`
processor_socket=""
processor_description=`sysctl -n machdep.cpu.brand_string`
processor_speed=`system_profiler SPHardwareDataType | grep "Processor Speed:" | cut -d":" -f2 | sed 's/^ *//g' | cut -d" " -f1 | sed 's/,/./g'`
processor_speed=`echo "scale = 0; $processor_speed*1000" | bc`
processor_manufacturer="GenuineIntel"

echo  " <processor>" >> $xml_file
echo  "     <item>" >> $xml_file
echo  "         <physical_count>$processor_count</physical_count>" >> $xml_file
echo  "         <core_count>$processor_cores</core_count>" >> $xml_file
echo  "         <logical_count>$processor_logical</logical_count>" >> $xml_file
echo  "         <socket>$processor_socket</socket>" >> $xml_file
echo  "         <description>$processor_description</description>" >> $xml_file
echo  "         <speed>$processor_speed</speed>" >> $xml_file
echo  "         <manufacturer>$processor_manufacturer</manufacturer>" >> $xml_file
echo "          <architecture>x64</architecture>" >> $xml_file
echo  "     </item>" >> $xml_file
echo  " </processor>" >> $xml_file

if [ "$debugging" -gt "2" ]; then
    echo "Memory Info"
fi
echo "  <memory>" >> $xml_file
for line in $(system_profiler SPMemoryDataType | grep "BANK" -A 8); do

    if [[ "$line" == *"BANK"* ]]; then
        memory_tag=`echo "$line" | cut -d"/" -f1 | sed 's/^ *//'`
        memory_bank=`echo "$memory_tag" | sed 's/BANK/DIMM/g'`
    fi

    if [[ "$line" == *"Size"* ]]; then
        memory_capacity=`echo "$line" | grep "Size:" | cut -d":" -f2 | sed 's/^ *//g' | cut -d" " -f1 | sed 's/,/./g'`
        memory_capacity=`echo "scale = 0; $memory_capacity * 1024" | bc`
    fi

    if [[ "$line" == *"Type"* ]]; then
        memory_detail=`echo "$line" | grep "Type:" | cut -d":" -f2 | sed 's/^ *//g'`
    fi

    if [[ "$line" == *"Speed"* ]]; then
        memory_speed=`echo "$line" | grep "Speed:" | cut -d":" -f2 | sed 's/^ *//g'`
    fi

    if [[ "$line" == *"Serial Number"* ]]; then
        memory_serial=`echo "$line" | grep "Serial Number:" | cut -d":" -f2 | sed 's/^ *//g'`

        echo "      <item>" >> $xml_file
        echo "          <bank>$memory_bank</bank>" >> $xml_file
        echo "          <type></type>" >> $xml_file
        echo "          <form_factor></form_factor>" >> $xml_file
        echo "          <detail>$memory_detail</detail>" >> $xml_file
        echo "          <size>$memory_capacity</size>" >> $xml_file
        echo "          <speed>$memory_speed</speed>" >> $xml_file
        echo "          <tag>$memory_tag</tag>" >> $xml_file
        echo "          <serial>$memory_serial</serial>" >> $xml_file
        echo "      </item>" >> $xml_file
    fi
done
#unset IFS
echo "  </memory>" >> $xml_file

if [ "$debugging" -gt "2" ]; then
    echo "OS: $system_os_version"
    echo "MAJ: $system_os_version_major"
    echo "MIN: $system_os_version_minor"
    echo "Hard Disks"
fi
# NOTES -
# manufacturer not available on SATA conntected disks
# model not available on USB connected disks
# partition count not available
# scsi logical unit not available


echo "  <disk>" >> $xml_file
partition_each=""
if [ "$debugging" -gt 3 ]; then
    echo "COMMAND: diskutil list | grep "^/" | cut -d/ -f3 | cut -d\" \" -f1"
fi
for disk in $(diskutil list | grep "^/" | cut -d/ -f3 | cut -d" " -f1); do
    hard_drive_index=$disk
    if [ "$debugging" -gt 3 ]; then
        echo "COMMAND: diskutil info $disk | grep \"^ \" | grep \"Device / Media Name:\" | cut -d\":\" -f2- | sed 's/^ *//g'"
    fi
    hard_drive_caption=$(diskutil info "$disk" | grep "^ " | grep "Device / Media Name:" | cut -d":" -f2- | sed 's/^ *//g')
    if [ "$debugging" -gt 3 ]; then
        echo "COMMAND: diskutil info $disk | grep \"^ \" | grep \"Protocol:\" | cut -d\":\" -f2- | sed 's/^ *//g'"
    fi
    hard_drive_interface_type=$(diskutil info "$disk" | grep "^ " | grep "Protocol:" | cut -d":" -f2- | sed 's/^ *//g')
    if [ "$system_os_version_major" -ge 10 ] && [ "$system_os_version_minor" -ge 12 ]; then
        if [ "$debugging" -gt 3 ]; then
            echo "COMMAND: diskutil info $disk | grep \"^ \" | grep \"Disk Size:\" | cut -d\":\" -f2- | sed 's/^ *//g' | cut -d\" \" -f3 | cut -d\"(\" -f2"
        fi
        hard_drive_size=$(diskutil info "$disk" | grep "^ " | grep "Disk Size:" | cut -d":" -f2- | sed 's/^ *//g' | cut -d" " -f3 | cut -d"(" -f2)
        if [ "$debugging" -gt 3 ]; then
            echo "COMMAND: echo \"$hard_drive_size / 1000 / 1000 \" | bc | cut -d\".\" -f1"
        fi
        hard_drive_size=$(echo "$hard_drive_size / 1000 / 1000 " | bc | cut -d"." -f1)
    else
        if [ "$debugging" -gt 3 ]; then
            echo "COMMAND: diskutil info $disk | grep \"^ \" | grep \"Total Size:\" | cut -d\":\" -f2- | sed 's/^ *//g' | cut -d\" \" -f3 | cut -d\"(\" -f2"
        fi
        hard_drive_size=$(diskutil info "$disk" | grep "^ " | grep "Total Size:" | cut -d":" -f2- | sed 's/^ *//g' | cut -d" " -f3 | cut -d"(" -f2)
        if [ "$debugging" -gt 3 ]; then
            echo "COMMAND: echo \"$hard_drive_size / 1000 / 1000 \" | bc | cut -d\".\" -f1"
        fi
        hard_drive_size=$(echo "$hard_drive_size / 1000 / 1000 " | bc | cut -d"." -f1)
    fi

    hard_drive_device_id=$(diskutil info "$disk" | grep "^ " | grep "Device Node:" | cut -d":" -f2- | sed 's/^ *//g')
    hard_drive_status=$(diskutil info "$disk" | grep "^ " | grep "SMART Status:" | cut -d":" -f2- | sed 's/^ *//g')
    hard_drive_manufacturer=""
    hard_drive_model=""
    if [[ "$hard_drive_interface_type" == "SATA" ]]; then
        hard_drive_model=$(system_profiler SPSerialATADataType | grep "BSD Name: $disk$" -B8 | grep "Model:" | cut -d":" -f2 | sed 's/^ *//g' | sed 's/ *$//g')
        hard_drive_serial=$(system_profiler SPSerialATADataType | grep "BSD Name: $disk$" -B8 | grep "Serial Number:" | cut -d":" -f2 | sed 's/^ *//g' | sed 's/ *$//g')
        hard_drive_firmware=$(system_profiler SPSerialATADataType | grep "BSD Name: $disk$" -B8 | grep "Revision:" | cut -d":" -f2 | sed 's/^ *//g' | sed 's/ *$//g')
    fi
    if [[ "$hard_drive_interface_type" == "USB" ]]; then
        hard_drive_serial=$(system_profiler SPUSBDataType 2>/dev/null | grep "BSD Name: $disk$" -B12 | grep "Serial Number:" | cut -d":" -f2 | sed 's/^ *//g' | sed 's/ *$//g')
        hard_drive_firmware=$(system_profiler SPUSBDataType 2>/dev/null | grep "BSD Name: $disk$" -B12 | grep "Version:" | cut -d":" -f2 | sed 's/^ *//g' | sed 's/ *$//g')
        hard_drive_manufacturer=$(system_profiler SPUSBDataType 2>/dev/null | grep "BSD Name: $disk$" -B12 | grep "Manufacturer:" | cut -d":" -f2 | sed 's/^ *//g' | sed 's/ *$//g')
    fi
    if [[ "$hard_drive_model" == *"APPLE"* ]]; then
        hard_drive_manufacturer="Apple"
    fi
    test=""
    test=$(diskutil info "$disk" | grep "^ "| grep "This disk is a Core Storage Logical Volume")
    if [ -n "$test" ]; then
        # we have a LVM - likely the data partition used on the main disk
        # get some extra info we would normally only get for a partition
        partition_device_id=$(diskutil info "$disk" | grep "^ " | grep "Volume UUID:" | cut -d":" -f2- | sed 's/^ *//g')
        hard_drive_index=$(system_profiler SPStorageDataType | grep "Volume UUID: $partition_device_id" -A20 | grep "Physical Volumes:" -A1 | grep -v "Physical" | cut -d":" -f1 | cut -d"s" -f2 | sed 's/^ *//g')
        hard_drive_index="dis$hard_drive_index"
        partition_mount_point=$(diskutil info "$disk" | grep "^ " | grep "Mount Point:" | cut -d":" -f2- | sed 's/^ *//g')
        partition_name=$(diskutil info "$disk" | grep "^ " | grep "Volume Name:" | cut -d":" -f2- | sed 's/^ *//g')
        #partition_size="$hard_drive_size"
        #if [ "$system_os_version_major" -ge 10 ] && [ "$system_os_version_minor" -ge 12 ]; then
            #partition_free_space=""
            #partition_used_space=""
        #else
            #partition_free_space=$(diskutil info "$disk" | grep "^ " | grep "Volume Free Space:" | cut -d":" -f2- | sed 's/^ *//g' | cut -d" " -f3 | cut -d"(" -f2)
            #partition_free_space=$(echo "$partition_free_space / 1000 / 1000 " | bc | cut -d"." -f1)
            #partition_used_space=$(echo "$partition_size - $partition_free_space" | bc | cut -d"." -f1)
        #fi
        partition_format=$(diskutil info "$disk" | grep "^ " | grep "File System Personality:" | cut -d":" -f2- | sed 's/^ *//g')
        partition_caption=$(diskutil info "$disk" | grep "^ " | grep "Volume Name:" | cut -d":" -f2- | sed 's/^ *//g')
        partition_disk_index=$(system_profiler SPStorageDataType | grep "Volume UUID: $partition_device_id" -A20 | grep "Physical Volumes:" -A1 | grep -v "Physical" | cut -d":" -f1 | sed 's/^ *//g')
        partition_each="$partition_each       <item>"$'\n'
        #partition_each="$partition_each           <serial>$partition_serial</serial>"$'\n'
        partition_each="$partition_each           <hard_drive_index>$hard_drive_index</hard_drive_index>"$'\n'
        partition_each="$partition_each           <mount_type>partition</mount_type>"$'\n'
        partition_each="$partition_each           <mount_point><![CDATA[$partition_mount_point]]></mount_point>"$'\n'
        partition_each="$partition_each           <name>$partition_name</name>"$'\n'
        #partition_each="$partition_each           <size>$partition_size</size>"$'\n'
        #partition_each="$partition_each           <free>$partition_free_space</free>"$'\n'
        #partition_each="$partition_each           <used>$partition_used_space</used>"$'\n'
        partition_each="$partition_each           <format>$partition_format</format>"$'\n'
        partition_each="$partition_each           <description>$partition_caption</description>"$'\n'
        partition_each="$partition_each           <device>$partition_device_id</device>"$'\n'
        partition_each="$partition_each           <partition_disk_index>$partition_disk_index</partition_disk_index>"$'\n'
        partition_each="$partition_each           <bootable></bootable>"$'\n'
        partition_each="$partition_each           <type>local</type>"$'\n'
        partition_each="$partition_each       </item>"$'\n'
    else
        echo "      <item>" >> $xml_file
        echo "          <caption>$hard_drive_caption</caption>" >> $xml_file
        echo "          <hard_drive_index>$hard_drive_index</hard_drive_index>" >> $xml_file
        echo "          <interface_type>$hard_drive_interface_type</interface_type>" >> $xml_file
        echo "          <manufacturer>$hard_drive_manufacturer</manufacturer>" >> $xml_file
        echo "          <model>$hard_drive_model</model>" >> $xml_file
        echo "          <serial>$hard_drive_serial</serial>" >> $xml_file
        echo "          <size>$hard_drive_size</size>" >> $xml_file
        echo "          <device>$hard_drive_device_id</device>" >> $xml_file
        echo "          <status>$hard_drive_status</status>" >> $xml_file
        echo "          <firmware>$hard_drive_firmware</firmware>" >> $xml_file
        echo "      </item>" >> $xml_file
        # partitions on this disk
        for partition in $(diskutil list | grep "  $disk"s.\$ | awk 'NF>1{print $NF}'); do
            partition_mount_point=$(diskutil info "$partition" | grep "^ " | grep "Mount Point:" | cut -d":" -f2 | sed 's/^ *//g' | sed 's/ *$//g')
            partition_name=$(diskutil info "$partition" | grep "^ " | grep "Volume Name:" | cut -d":" -f2- | sed 's/^ *//g' | sed 's/ *$//g')
            if [ "$partition_name" == "Not applicable (no file system)" ]; then
                partition_name=$(diskutil info "$partition" | grep "^ " | grep "Device / Media Name:" | cut -d":" -f2- | sed 's/^ *//g' | sed 's/ *$//g')
            fi
            partition_format=$(diskutil info "$partition" | grep "^ " | grep "File System Personality:" | cut -d":" -f2 | sed 's/^ *//g' | sed 's/ *$//g')
            partition_caption=$(diskutil info "$partition" | grep "^ " | grep "Volume Name:" | cut -d":" -f2 | sed 's/^ *//g' | sed 's/ *$//g')
            partition_device_id=$(diskutil info "$partition" | grep "^ " | grep "Volume UUID:" | cut -d":" -f2 | sed 's/^ *//g' | sed 's/ *$//g')
            partition_disk_index=$(diskutil info "$partition" | grep "^ " | grep "Device Identifier:" | cut -d":" -f2 | sed 's/^ *//g' | sed 's/ *$//g')
            partition_each="$partition_each       <item>"$'\n'
            partition_each="$partition_each           <hard_drive_index>$hard_drive_index</hard_drive_index>"$'\n'
            partition_each="$partition_each           <mount_type>partition</mount_type>"$'\n'
            partition_each="$partition_each           <mount_point><![CDATA[$partition_mount_point]]></mount_point>"$'\n'
            partition_each="$partition_each           <name>$partition_name</name>"$'\n'
            partition_each="$partition_each           <format>$partition_format</format>"$'\n'
            partition_each="$partition_each           <description>$partition_caption</description>"$'\n'
            partition_each="$partition_each           <device>$partition_device_id</device>"$'\n'
            partition_each="$partition_each           <partition_disk_index>$partition_disk_index</partition_disk_index>"$'\n'
            partition_each="$partition_each           <type>local</type>"$'\n'
            partition_each="$partition_each       </item>"$'\n'
        done
    fi
done
echo "  </disk>" >> $xml_file
echo "   <partition>" >> $xml_file
echo "$partition_each</partition>" >> $xml_file



if [ "$debugging" -gt "2" ]; then
    echo "Software Info"
fi
echo "  <software>" >> $xml_file
# include OS in software
echo "      <item>" >> $xml_file
echo "          <name><![CDATA[$system_os_name]]></name>" >> $xml_file
echo "          <version><![CDATA[$system_os_version]]></version>" >> $xml_file
echo "          <publisher>Apple</publisher>" >> $xml_file
echo "      </item>" >> $xml_file
software_name=""
software_version=""
software_install_source=""
for line in $(system_profiler SPApplicationsDataType | grep "Location: " -B 8 -A 1 | grep -e '^$' -v); do

    if [[ "$software_name" == "" && "$line" != *"Get Info String: "* && "$line" != *"Kind: "* ]]; then
        #software_name=`echo "$line"`     # | cut -d":" -f0 | sed 's/^ *//'`
        software_name=`echo "$line" | sed 's/^ *//'`
    fi

    if [[ "$software_name" == "--" ]]; then
        software_name=""
    fi

    if [[ "$line" == *"Version: "* ]]; then
        software_version=`echo "$line" | cut -d":" -f2 | sed 's/^ *//'`
    fi

    if [[ "$line" == *"App Store: Yes"* ]]; then
        software_install_source="Mac App Store"
    fi

    if [[ "$line" == *"App Store: No"* ]]; then
        software_install_source="Unknown"
    fi

    if [[ "$line" == *"Obtained from: "* ]]; then
        software_install_source=`echo "$line" | cut -d":" -f2 | sed 's/^ *//'`
    fi

    if [[ "$line" == *"Signed by: Developer ID Application"* ]]; then
        software_publisher=`echo "$line" | cut -d":" -f3 | cut -d"," -f1 | sed 's/^ *//'`
    fi

    if [[ "$line" == *"Signed by: Microsoft Corporation"* ]]; then
        software_publisher="Microsoft"
    fi

    if [[ "$software_install_source" == "Apple" ]]; then
        software_publisher="Apple"
    fi

    # the below line appears (sometimes) after the Location: line.
    # Commenting out for now as it's not easy to retrieve this for 'some' packages only
    # if [[ "$line" == *"Get Info String: "* && "$software_publisher" == "" ]]; then
    #     software_publisher=`echo "$line" | sed 's/^ *//'`
    #     software_publisher=`echo "$software_publisher" | sed 's/^Get Info String: //'`
    # fi

    if [[ "$line" == *"Location:"* ]]; then
        software_location=`echo "$line" | cut -d":" -f2 | sed 's/^ *//'`
        software_name=`echo $software_name | cut -d":" -f1`
        echo "      <item>" >> $xml_file
        echo "          <name><![CDATA[$software_name]]></name>" >> $xml_file
        echo "          <version><![CDATA[$software_version]]></version>" >> $xml_file
        echo "          <location><![CDATA[$software_location]]></location>" >> $xml_file
        echo "          <install_source>$software_install_source</install_source>" >> $xml_file
        echo "          <publisher><![CDATA[$software_publisher]]></publisher>" >> $xml_file
        echo "      </item>" >> $xml_file
        software_name=""
        software_version=""
        software_location=""
        software_install_source=""
        software_publisher=""
    fi
done
echo "  </software>" >> $xml_file



if [ "$debugging" -gt "2" ]; then
    echo "Software Keys"
fi
echo "  <software_keys>" >> $xml_file
key_name=""
key_release=""
key_text=""
# Adobe CS5 and later
if [ -d /Library/Application\ Support/regid.1986-12.com.adobe/ ] ; then
    # Read each each found file and add its product to a list
    for AFILE in /Library/Application\ Support/regid.1986-12.com.adobe/*
    do
        key_name=$( sed -n -e 's/.*<swid:product_title>\(.*\)<\/swid:product_title>.*/\1/p' "$AFILE" )
        key_release=$( sed -n -e 's/.*<swid:activation_status>\(.*\)<\/swid:activation_status>.*/\1/p' "$AFILE" )
        key_text=$( sed -n -e 's/.*<swid:serial_number>\(.*\)<\/swid:serial_number>.*/\1/p' "$AFILE" )
        echo "      <key>" >> $xml_file
        echo "          <key_name><![CDATA[$key_name]]></key_name>" >> $xml_file
        echo "          <key_text><![CDATA[$key_text]]></key_text>" >> $xml_file
        echo "          <key_release><![CDATA[$key_release]]></key_release>" >> $xml_file
        echo "          <key_edition>OSX</key_edition>" >> $xml_file
        echo "      </key>" >> $xml_file
        key_name=""
        key_release=""
        key_text=""
    done
fi

key_name=""
key_release=""
key_text=""

# Adobe CS4
if [ -d /Users/Shared/Adobe/ISO-19770/ ] ; then
    # Read each found file add its product to the list
    for AFILE in /Users/Shared/Adobe/ISO-19770/*
    do
        key_name=$( sed -n -e 's/.*<sat:product_title>\(.*\)<\/sat:product_title>.*/\1/p' "$AFILE" )
        # Some products use a different version of SWID Tag where "sat:product_title" isn't valid.
        # If "sat:product_title" isn't found in the tag then assume "product".
        if [ "$key_name" = "" ] ; then
            key_name=$( sed -n -e 's/.*<product>\(.*\)<\/product>.*/\1/p' "$AFILE" )
            key_suite=$( sed -n -e 's/.*<part_of_suite>\(.*\)<\/part_of_suite>.*/\1/p' "$AFILE" )

            # Some products such as Acrobat Pro may exist but this older version
            # of SWID Tag will only indicate that it was part of a suite or standalone.
            # Report if the product is part of a suite.

            if [ "$key_suite" = "true" ] ; then
                key_name="$key_name is part of an unknown CS4 suite"
            fi
        fi
        key_release=$( sed -n -e 's/.*<sat:activation_status>\(.*\)<\/sat:activation_status>.*/\1/p' "$AFILE" )
        echo "      <key>" >> $xml_file
        echo "          <key_name><![CDATA[$key_name]]></key_name>" >> $xml_file
        echo "          <key_text></key_text>" >> $xml_file
        echo "          <key_release><![CDATA[$key_release]]></key_release>" >> $xml_file
        echo "          <key_edition>OSX</key_edition>" >> $xml_file
        echo "      </key>" >> $xml_file
        key_name=""
        key_release=""
        key_text=""
    done
fi


echo "  </software_keys>" >> $xml_file




echo "</system>" >> $xml_file


if [ "$submit_online" = "y" ]; then
    if [ "$debugging" -gt 0 ]; then
        echo "Submitting results to server"
    fi
    if [ "$debugging" -gt 3 ]; then
        curl -o input_devices --data-urlencode data@"$xml_file" $url
        cat "input_devices"
        rm -f input_devices
    else
        curl --data-urlencode data@"$xml_file" $url >/dev/null 2>&1
        #rm -f input_devices
    fi
fi


if [ "$terminal_print" = "y" ]; then
    cat "$xml_file"
fi


if [ "$create_file" != "y" ]; then
    `rm -f $xml_file`
fi
if [ "$debugging" -gt 0 ]; then
    echo "Audit Completed"
fi

IFS=$O
}
##End-outside-code###

############################


function main {

  #verify_signature
  # Verify Lockdown signature
  #macos_compatability_check
  # Check the system is running the supoorted version of macOS

  declare -r cmd=${1:-"usage"}
  declare -a settings
  declare -i setting_index=-1
  declare audit_setting_num
  declare fix_setting_num
  declare t2_mac="False"
  declare is_vm="False"
  declare is_codesigned="False"
  declare sip="False"

  settings=(disable_automatic_system_updates disable_automatic_app_store_updates disable_firewall enable_admin_password_preferences \
                  set_5minute_time_lock_and_sleep_computer enable_terminal_secure_entry enable_filevault disable_remote_login)

  trap ctrl_c SIGINT
  # Detect and react to the user hitting CTRL + C

  case "${cmd}" in

    list)
      echo -e "\\nSettings (${BOLD}${#settings[@]}${RESET}) that can be audited or fixed: "

      for setting in "${settings[@]}"; do
        setting_index=$((setting_index+1))

        # shellcheck disable=SC2116
        setting_read="$(echo "${setting//_/ }")"
        # Replace underscore with a space, more human readable
        echo "  (${RED}${setting_index}${RESET}) ${setting_read}"
      done

      echo
      exit 0
      ;;

    audit|fullaudit)
      if [[ "${cmd}" = "fullaudit" ]]; then
        system_hostname=$(hostname | cut -d. -f1)
        xml_file="$system_hostname"-`date +%Y%m%d%H%M%S`.xml
        xml_file_full_path=`pwd`"/$xml_file"
      fi
      audit_setting_num=${2:--1}

      check_index "${audit_setting_num}"
      sudo_prompt
      if [[ "${cmd}" = "fullaudit" ]]; then
        echo  "<?xml version="\"1.0\"" encoding="\"UTF-8\""?>" >> $xml_file
        echo  "<system>" >> $xml_file
        echo  " <audit>" >> $xml_file
        echo -e "\\nResults: "
      fi
      if ! [ "${audit_setting_num}" -lt 0 ]; then
        "${settings[${audit_setting_num}]}" "audit"
      else

        for setting in "${settings[@]}"; do
          "${setting}" "audit"
          # Call functions in 'settings' array with the argument 'audit'
        done
      fi
      if [[ "${cmd}" = "fullaudit" ]]; then
        echo  " </audit>" >> $xml_file
        getinfo
      fi
      if [[ "${cmd}" = "fullaudit" && -e /opt/fusioninventory-agent/bin/fusioninventory-agent ]]; then
	      echo "Starting FusionInventory-agent"
        fusionagent=$(sudo /opt/fusioninventory-agent/bin/fusioninventory-agent)
        echo $fusionagent
      fi
      echo
      ;;

    fix|fix-force)
      fix_setting_num=${2:--1}

      check_index "${fix_setting_num}"

      if [[ "${cmd}" != "fix-force" ]]; then
        # Confirm the user wants to run FIX mode
        # If "fix force" skip the prompt
          get_fix_mode_permission
      fi

      echo -e "\\nResults: "

      if ! [ "${fix_setting_num}" -lt 0  ]; then
        "${settings[${fix_setting_num}]}" "audit"

      else

        for setting in "${settings[@]}"; do

          if ! "${setting}" "audit" >/dev/null; then
          # Run the audit command first
          # Only run the fix command if audit fails
          "${setting}" "fix"
          fi
        done
      fi

      echo
      ;;

    debug)
      debug
      ;;

    usage|help|-h|--help|ü§∑‚Äç‚ôÇÔ∏è|ü§∑‚Äç‚ôÄÔ∏è)
      usage
      ;;

    version|-v|--version)
      version
      ;;

    *)
      echo -e "\\n  [‚ùå] ${RED}Invalid command:${RESET} ${cmd}"
      exit 1
      ;;

  esac

}

main "$@"
